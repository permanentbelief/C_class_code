网易互娱面经(5-31)
1.讲讲你理解的进程虚拟空间

> 进程的虚拟地址空间是操作系统为每一个进程开辟的虚拟地址空间，一段连续的假地址。看似每一个进程都有一段连续的4G空间，其实不然，其实只是操作系统为了使进程能利用连续的地址而开辟的，进程的虚拟地址空间是依靠页表映射物理内存上的一块空间。等到我们每一个进程利用空间的时候，通过页表进行向物理内存上的映射，页表建立的一层映射关系。（在通过MMU内存管理单元将虚拟地址空间映射到物理内存地址中）

2.如果现在磁盘不够了，还要往里存，虚拟空间会怎么办

>在交换分区做内存置换。Swap分区是在系统的物理内存不够用的时候，把硬盘中的内存一部分空间释放出来，那些被释放的空间可能来自于很长时间没有操作的程序，这些释放的空间被临时保存到Swap分区， 等到程序使用的时候，再恢复数据到内存中去。

3.c++static和const关键字的作用

 1.  static关键字修饰成员函数的时候不属于某一个类，属于全局。
 2.  static修饰函数的时候，改变其作用域只在这个.cpp文件中
 3.  static修饰局部变量，改变其生命周期，使得其生命周期出了作用域依然存在
 4.  修饰全局函数，改变其生命周期
 4.  const修饰变量，不可改变变量的值
 5.  const修饰参数，使得参数不能被改变
 6.  const修饰成员函数，使得成员变量不能被修改。
 
4.你理解的多态，原理

> 多态就是不同的对象调用同一种方法，产生不同的效果。
多态的原理就是：子类重写父类的虚函数，并且在子类的虚函数表中完成基类虚函数的覆盖，产生了多态调用，调用的函数只与对象有关，和类就没有关系。

5.c++11的移动语义和右值引用

> C++11的右值引用就是，先简单介绍一下右值，右值分为将亡值和常量值，常量比如1+2，将亡值也是临时值比如 string str1 ,string str2, string str3 = str1 + str2, return str3. 这个str3就是将亡值，出了这个函数的作用域，这个str3就会被销毁，所以也就是多了一次拷贝构造的代价。
这就是C++11移动语义的产生，为了解决这多一次的拷贝构造问题，所以产生了移动语义。

6.程序的预处理和编译，链接，具体都作什么事（包括未决符号表等等符号表）

 1. 预处理：去注释，宏替换，条件编译，展开
 2. 编译：语法检查，将.i文件转换为汇编语言 .s文件
 3. 汇编：将汇编转换为机器识别的二进制码.o文件
 4. 连接：将多个.o文件合成一个文件。每一个.o文件都有符号表，填充符号表里面的函数地址。

7.进程和线程的区别

 1. 进程就是任务，进程是一个运行中程序的描述，pcb是进程控制块，linux下pcb是tast_struct结构体。记录着进程描述的各种信息。对于操作系统来说，进程就是一个pcb,操作系统对运行中程序的描述来控制程序的运行过程。
 2. 线程是一个轻量级进程，是通过进程pcb实现的，在linux下，线程是一个轻量级的进程，并且对同一线程组中的线程共用一个虚拟地址空间，所以linux下的pcb相较于传统的pcb更加轻量化，是叫做轻量级进程。

8.进程间通信的方式，各个特点，你平时使用过哪些

 1. 管道  用于字节流式传输，自带同步与互斥，管道声明周期随进程
 2. 消息队列 用于块文件传输，随内核，接口复杂且操作困难，用于块文件的传输
 3. 共享内存 最快的通信方式，多个进程在物理内存上建立映射，可以实现数据的共享。
 4. 信号量 实现通信间的同步与互斥，不参与数据通信、

9.进程的同步和互斥，通过什么方式进行

> 信号量  和 信号


10.多线程的互斥，同步的执行流，怎么判断挂起等待，什么时候进入

> 多线程通过条件变量和出斥锁来实现，对执行流的同步与互斥的判断，当条件变量有资源时，唤醒在条件变量上阻塞等待的线程，

11.udp和tcp的区别，使用场景

> 段落引用

12.tcp怎么保证稳定性，滑动窗口和拥塞控制，为什么握手三次，挥手四次

> 序号和确认序号，确认应答机制，超时重传机制，滑动窗口，拥塞控制进制
滑动窗口：可以在窗口间发送数据，窗口的大小就是发送数据的最大值，不用一条条的发送在确认应答回复，这样就很慢，
拥塞控制： 慢启动，拥塞避免，快速重传，

13.tcp怎么解决粘包问题

> tcp在传输层的时候对数据边界不敏感，所以要在应用层进行控制。
1. 发送的数据定长
2. 固定的字符间隔，需要注意转移
3. 在应用层头部加上不定长数据段的长度字段

14.**高级IO，select和epoll，边缘触发和水平触发** 还没复习

15.算法：栈实现队列

> 略

16.socket常用接口

 1. socket()创建套接字
 2. bind()绑定地址信息
 3. connect() 客户端进行三次握手连接服务端
 4. listen()监听套接字
 5. accept()服务端套接字建立连接
 6. recv() 接收信息
 7. send to（） 发送信息

17.vector和list底层实现，红黑树和哈希底层原理

 1. vector的底层是一段连续的地址空间
 2. list的底层是一个双向链表
 3. 红黑树的原理：
    1. 红黑树只有红节点或黑节点
    2. 每一个路径的黑节点数目相同
    3. 头节点是红节点
    4. 每一个叶子节点都是黑色
    5. 红节点的儿子节点不能是红节点
红黑树是一颗近似平衡的二叉搜索树，查找和删除的效率都与高度有关系，都是O(logn)
4 哈希底层是 哈希表，是带有散列关系的映射数组，通过key值的映射，得到位置。所以查找的效率为O(1)

18.哈希冲突怎么解决，哈希桶

 1. 开散列-线性探测法.遇到冲突，向后探测，这样的坏处是，冲突的地方容易堆积，所以每一次的效率接近于O(n)
 2. 开散列-二次探测法 ，f(i) + i^i,多加一个平衡因子设置为0.8左右，避免发生冲突.
 3. 闭散列-链地址法，也就是哈希桶，映射到一个桶中，通过链表的头插，连接到桶中。

19.编程，模拟实现strllength
char * mystrlen(const char* str)
{
    assert(str);
    int count = 0;
    char* s_str = str;
    while(*s_str)
    {
        count++;
        s_str++;
    }
}
    

